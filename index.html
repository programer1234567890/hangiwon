<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë„¤ì˜¨ ì„œí‚·: ë ˆì¸ ëŸ¬ë„ˆ ëª¨ë“œ</title>
    <!-- Tailwind CSS CDN (ìŠ¤íƒ€ì¼ë§ìš©) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js CDN (3D ê·¸ë˜í”½ìš©) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Firebase CDN (ë°ì´í„°ë² ì´ìŠ¤ ë° ì¸ì¦ìš©) -->
    <script type="module">
        // Firebase ëª¨ë“ˆ ì„í¬íŠ¸
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Firestore ë¡œê¹… í™œì„±í™” (ë””ë²„ê¹…ìš©)
        setLogLevel('Debug');

        // ì „ì—­ ë³€ìˆ˜ ì„¤ì • ë° ì´ˆê¸°í™”
        window.THREE = THREE; 
        window.Game = {}; 

        // 1. Firebase ì„¤ì • ë° ì´ˆê¸°í™”
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');

        if (Object.keys(firebaseConfig).length > 0) {
            window.Game.app = initializeApp(firebaseConfig);
            window.Game.db = getFirestore(window.Game.app);
            window.Game.auth = getAuth(window.Game.app);
        } else {
            console.error("Firebase Configuration is missing.");
            window.Game.db = null;
        }

        // 2. ì¸ì¦ ë° ì‚¬ìš©ì ID ì„¤ì •
        if (window.Game.db) {
            const auth = window.Game.auth;
            const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    window.Game.userId = user.uid;
                    document.getElementById('user-id-display').textContent = `ì‚¬ìš©ì ID: ${user.uid}`;
                    console.log("Firebase Auth Ready. User ID:", window.Game.userId);
                    // ì¸ì¦ ì™„ë£Œ í›„ ìµœê³  ì ìˆ˜ ë¡œë“œ
                    if (window.Game.loadHighScore) {
                        window.Game.loadHighScore(window.Game.db, appId, user.uid);
                    }
                } else {
                    try {
                        // ì‚¬ìš©ì í† í°ì´ ìˆìœ¼ë©´ ë¡œê·¸ì¸, ì—†ìœ¼ë©´ ìµëª… ë¡œê·¸ì¸ ì‹œë„
                        if (initialAuthToken) {
                            await signInWithCustomToken(auth, initialAuthToken); 
                        } else {
                            await signInAnonymously(auth);
                        }
                    } catch (error) {
                        console.error("Firebase Authentication Error:", error);
                    }
                }
            });

            // 3. High Score ê´€ë¦¬ í•¨ìˆ˜ - ë¶ˆëŸ¬ì˜¤ê¸°
            window.Game.loadHighScore = async (db, appId, userId) => {
                // ê°œì¸ ë°ì´í„° ê²½ë¡œ: /artifacts/{appId}/users/{userId}/{collectionName}/{documentId}
                const docRef = doc(db, `artifacts/${appId}/users/${userId}/gameData`, 'neonCircuit_highScore');
                try {
                    const docSnap = await getDoc(docRef);
                    if (docSnap.exists()) {
                        const savedScore = docSnap.data().score;
                        window.Game.highScore = savedScore;
                        document.getElementById('high-score').textContent = savedScore.toFixed(0);
                    } else {
                        window.Game.highScore = 0;
                    }
                } catch (e) {
                    console.error("Error loading document: ", e);
                    window.Game.highScore = 0;
                }
            };

            // 4. High Score ê´€ë¦¬ í•¨ìˆ˜ - ì €ì¥í•˜ê¸°
            window.Game.saveHighScore = async (db, appId, userId, newScore) => {
                const docRef = doc(db, `artifacts/${appId}/users/${userId}/gameData`, 'neonCircuit_highScore');
                // ê¸°ì¡´ ì ìˆ˜ì™€ ìƒˆ ì ìˆ˜ ì¤‘ ë” ë†’ì€ ì ìˆ˜ë¥¼ ì €ì¥
                const scoreToSave = Math.max(window.Game.highScore, newScore); 
                try {
                    await setDoc(docRef, { score: scoreToSave, lastUpdated: new Date() });
                    window.Game.highScore = scoreToSave;
                    document.getElementById('high-score').textContent = scoreToSave.toFixed(0);
                } catch (e) {
                    console.error("Error saving document: ", e);
                }
            };
        } else {
            // Firebaseê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì€ ê²½ìš° ë”ë¯¸ í•¨ìˆ˜ ì„¤ì •
            window.Game.loadHighScore = () => { window.Game.highScore = 0; document.getElementById('high-score').textContent = 'N/A (No DB)'; };
            window.Game.saveHighScore = () => { console.warn("Cannot save score: DB not initialized."); };
            window.Game.highScore = 0;
        }

    </script>
    <style>
        /* ì»¤ìŠ¤í…€ ìŠ¤íƒ€ì¼ ë° ë„¤ì˜¨ íš¨ê³¼ */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #000;
            color: #fff;
            overflow: hidden; /* ìŠ¤í¬ë¡¤ ë°©ì§€ */
        }
        #game-container {
            width: 100%;
            height: 100vh;
        }
        canvas {
            display: block;
            border-radius: 0.75rem; 
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.5), 0 0 20px rgba(0, 255, 255, 0.25);
        }
        .neon-button {
            padding: 1rem 2rem;
            font-size: 1.25rem;
            font-weight: bold;
            color: #0ff; 
            background: #000;
            border: 2px solid #0ff;
            border-radius: 9999px; 
            box-shadow: 0 0 10px #0ff, inset 0 0 5px #0ff;
            transition: all 0.3s ease-in-out;
        }
        .neon-button:hover {
            color: #000;
            background: #0ff;
            box-shadow: 0 0 20px #0ff, inset 0 0 10px #0ff;
            transform: scale(1.05);
        }
        .neon-text {
            text-shadow: 0 0 5px #f0f, 0 0 10px #f0f, 0 0 20px #0ff, 0 0 40px #0ff;
            color: #fff;
        }
        .message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid #f0f;
            border-radius: 1rem;
            padding: 2rem;
            box-shadow: 0 0 20px #f0f, 0 0 40px rgba(255, 0, 255, 0.5);
            text-align: center;
            z-index: 1000;
            max-width: 90%;
            width: 400px;
        }
    </style>
</head>
<body>

<!-- Tailwindë¥¼ ì‚¬ìš©í•˜ì—¬ ì „ì²´ í™”ë©´ ì»¨í…Œì´ë„ˆ ë° ì¤‘ì•™ ì •ë ¬ ì ìš© -->
<div id="game-container" class="relative w-full h-screen flex flex-col items-center justify-center bg-black">
    <canvas id="neon-circuit-canvas"></canvas>

    <!-- UI Overlay (Tailwindë¡œ ê°„ê²© ë° ìŠ¤íƒ€ì¼ ê°œì„ ) -->
    <div class="absolute top-0 left-0 w-full p-4 flex justify-between text-xl font-mono">
        <div class="p-2 bg-black/70 rounded-lg neon-text shadow-lg">
            ì ìˆ˜: <span id="current-score">0</span>
        </div>
        <div class="p-2 bg-black/70 rounded-lg neon-text text-yellow-300 shadow-lg">
            ìµœê³  ì ìˆ˜: <span id="high-score">0</span>
        </div>
    </div>

    <!-- Message/Start Screen -->
    <div id="game-message" class="message-box">
        <h1 class="text-3xl font-bold mb-4 neon-text text-green-500">ğŸ® ë„¤ì˜¨ ì„œí‚·: ë ˆì¸ ëŸ¬ë„ˆ ğŸš€</h1>
        <p class="mb-8 font-bold text-yellow-300">ì¡°ì‘ë²•: A/D ë˜ëŠ” â—€/â–¶ í‚¤ë¡œ ì¢Œìš° ì´ë™í•˜ì—¬ ë²½ì„ í”¼í•˜ì„¸ìš”.</p>
        <p class="mb-8 font-bold text-red-400">ì†ë„ê°€ ê³„ì† ë¹¨ë¼ì§€ë‹ˆ ì£¼ì˜!</p>
        <button id="start-button" class="neon-button">ê²Œì„ ì‹œì‘</button>
    </div>

    <!-- Footer for User ID -->
    <div id="user-id-display" class="absolute bottom-0 right-0 p-2 text-xs text-gray-500 bg-black/50 rounded-tl-lg">
        ì‚¬ìš©ì ID: (ë¡œë”© ì¤‘...)
    </div>
</div>

<script type="module">
    // Firebase ì „ì—­ ê°ì²´ê°€ ë¡œë“œë  ë•Œê¹Œì§€ ëŒ€ê¸°
    if (typeof window.THREE === 'undefined') {
        console.error("Three.js is not loaded.");
    }

    const { THREE, Game } = window;
    const canvas = document.getElementById('neon-circuit-canvas');
    const messageBox = document.getElementById('game-message');
    const startButton = document.getElementById('start-button');
    const scoreDisplay = document.getElementById('current-score');
    const highScoreDisplay = document.getElementById('high-score');
    const gameContainer = document.getElementById('game-container'); 

    let scene, camera, renderer;
    let player, playerSpeed = 1.0; 
    let gameState = 'start'; 
    let score = 0;
    let highscore = Game.highScore || 0;
    let keys = {};
    let obstacleGenerationTimer = 0;
    let obstacles = [];
    let animationId = null; 

    // ìƒìˆ˜: í”Œë ˆì´ì–´ ë†’ì´ ë° ì¶©ëŒ ë°•ìŠ¤
    const PLAYER_HEIGHT = 1.5; // ì‹œì  ë†’ì´ì™€ ì¶©ëŒ ë°•ìŠ¤ ì¤‘ì‹¬ ë†’ì´ (ë°”ë‹¥ì— ê³ ì •)
    const COLLISION_HEIGHT = 1.8; // ì¶©ëŒ ë°•ìŠ¤ ë†’ì´ (ì¶©ëŒì„ ê°ì§€í•˜ê¸° ìœ„í•œ ë†’ì´)
    
    // ê²Œì„ ì„¤ì •
    const config = {
        baseForwardSpeed: 0.20, 
        forwardSpeed: 0.20,    
        accelerationRate: 0.0012, // ì†ë„ ì¦ê°€ìœ¨
        sideSpeed: 0.12,       
        laneWidth: 6.7,       // í„°ë„ í­
        trackHeight: 10,      
        numLanes: 3,           
        // ë³€ê²½ëœ ë¶€ë¶„: ì¥ì• ë¬¼ ê°„ê²© 8ë¡œ ê³ ì •
        obstacleZSpacing: 8,   
        maxObstacles: 50,  
        worldLength: 5000,
        cameraFOV: 65          
    };

    // 1. ì´ˆê¸°í™” í•¨ìˆ˜ (Initialization Function)
    function init() {
        // Scene 
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000); 

        // Camera (First-person view, Y-position is fixed on the ground)
        camera = new THREE.PerspectiveCamera(config.cameraFOV, window.innerWidth / window.innerHeight, 0.1, 1000); 
        camera.position.set(0, PLAYER_HEIGHT, 0); // í”Œë ˆì´ì–´ ë†’ì´ ê³ ì •
        player = camera; 
        player.rotation.z = 0; // íšŒì „ ì œê±°

        // Renderer
        renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);

        // Floor (Circuit Track)
        const floorGeometry = new THREE.PlaneGeometry(config.laneWidth * 2, config.worldLength * 2); 
        const floorMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff, 
            side: THREE.DoubleSide,
            wireframe: true, 
            transparent: true,
            opacity: 0.1 
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = Math.PI / 2; 
        floor.position.z = -config.worldLength; 
        scene.add(floor);
        window.Game.floor = floor;

        // Ceiling (Track Boundary - visibility reduced as it's just boundary)
        const ceiling = floor.clone();
        ceiling.position.y = config.trackHeight; 
        ceiling.rotation.x = -Math.PI / 2; 
        ceiling.material = new THREE.MeshBasicMaterial({ 
            color: 0x00ffff, 
            side: THREE.DoubleSide,
            wireframe: true, 
            transparent: true,
            opacity: 0.05 
        }); 
        scene.add(ceiling);
        window.Game.ceiling = ceiling;

        // Event Listeners
        window.addEventListener('resize', onWindowResize, false);
        window.addEventListener('keydown', onKeyDown, false);
        window.addEventListener('keyup', onKeyUp, false);
        startButton.addEventListener('click', startGame);

        // ì´ˆê¸° ìµœê³  ì ìˆ˜ ë¡œë“œ ë° í‘œì‹œ
        highScoreDisplay.textContent = highscore.toFixed(0);
    }

    // í‚¤ ë‹¤ìš´ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
    function onKeyDown(event) {
        // ì¢Œìš° ì´ë™ (A, D, ArrowLeft, ArrowRight)ë§Œ ì²˜ë¦¬
        const key = event.key.toLowerCase();
        if (key === 'a' || key === 'd' || key === 'arrowleft' || key === 'arrowright') {
            keys[key] = true;
        }
        if (event.key === 'ArrowLeft') keys['a'] = true;
        if (event.key === 'ArrowRight') keys['d'] = true;
    }

    function onKeyUp(event) {
        // ì¢Œìš° ì´ë™ í‚¤ í•´ì œë§Œ ì²˜ë¦¬
        const key = event.key.toLowerCase();
        if (key === 'a' || key === 'd' || key === 'arrowleft' || key === 'arrowright') {
            keys[key] = false;
        }
        if (event.key === 'ArrowLeft') keys['a'] = false;
        if (event.key === 'ArrowRight') keys['d'] = false;
    }

    // ê²Œì„ ì‹œì‘
    function startGame() {
        if (gameState === 'playing') return;

        if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = null;
        }

        resetGame();
        messageBox.style.display = 'none';
        gameState = 'playing';
        animate(); 
    }

    // ê²Œì„ ì´ˆê¸°í™”
    function resetGame() {
        score = 0;
        playerSpeed = 1.0; 
        
        player.position.set(0, PLAYER_HEIGHT, 0); // Y ìœ„ì¹˜ ê³ ì •

        // ì¥ì• ë¬¼ ì œê±°
        obstacles.forEach(obj => scene.remove(obj));
        obstacles = [];
        obstacleGenerationTimer = 0;
        scoreDisplay.textContent = '0';
        highScoreDisplay.textContent = Game.highScore ? Game.highScore.toFixed(0) : '0';
    }

    // 2. ê²Œì„ ë£¨í”„ (Animation)
    function animate() {
        animationId = requestAnimationFrame(animate);

        if (gameState === 'playing') {
            updateGame();
            checkCollision();
        }

        renderer.render(scene, camera);
    }

    // 3. ê²Œì„ ì—…ë°ì´íŠ¸ ë¡œì§
    function updateGame() {
        // A. í”Œë ˆì´ì–´ ì¢Œìš° ì´ë™ (Side to side)
        let sideMovement = 0;

        if (keys['a']) sideMovement -= config.sideSpeed;
        if (keys['d']) sideMovement += config.sideSpeed;
        
        // Xì¶• ì´ë™ ì œí•œ
        player.position.x += sideMovement * playerSpeed;
        player.position.x = Math.max(-config.laneWidth / 2, Math.min(config.laneWidth / 2, player.position.x));

        // B. ìˆ˜ì§ ì´ë™ ë° íšŒì „ ì œê±° (ì í”„, ì›…í¬ë¦¬ê¸°, ì¤‘ë ¥ ë°˜ì „ ì œê±°)
        player.position.y = PLAYER_HEIGHT; 
        player.rotation.z = 0; 

        // C. ì†ë„ ì¦ê°€ ë° ì ìˆ˜ ì—…ë°ì´íŠ¸
        config.forwardSpeed = config.baseForwardSpeed * playerSpeed + (Math.random() - 0.5) * 0.01;
        player.position.z -= config.forwardSpeed;

        playerSpeed += config.accelerationRate; 
        score = -player.position.z; 
        scoreDisplay.textContent = score.toFixed(0);

        // D. ì¥ì• ë¬¼ ìƒì„±
        obstacleGenerationTimer += config.forwardSpeed;
        // ì¥ì• ë¬¼ ê°„ê²©ì´ config.obstacleZSpacing(8)ë¡œ ê³ ì •ë¨
        if (obstacleGenerationTimer >= config.obstacleZSpacing) {
            generateObstacle();
            obstacleGenerationTimer = 0;
            // ì´ì „ì˜ ë™ì  ê°„ê²© ì„¤ì • ì½”ë“œ ì œê±°ë¨
        }

        // E. ì¥ì• ë¬¼ ì´ë™ ë° ì œê±°
        const playerZ = player.position.z;
        for (let i = 0; i < obstacles.length; i++) {
            const obstacle = obstacles[i];
            if (obstacle.position.z > playerZ + 5) {
                scene.remove(obstacle);
                obstacles.splice(i, 1);
                i--;
            }
        }
    }


    // 4. ì¥ì• ë¬¼ ìƒì„± í•¨ìˆ˜ (Lane Blockerë§Œ ìƒì„±)
    function generateObstacle() {
        // ì¥ì• ë¬¼ íƒ€ì…: Lane Blocker (ìˆ˜í‰ ì´ë™ë§Œ ê°€ëŠ¥í•˜ë¯€ë¡œ, ìˆ˜ì§ ìš”ì†ŒëŠ” ì œê±°)
        const spawnZ = player.position.z - 50;
        const lanePositions = [-config.laneWidth/3, 0, config.laneWidth/3]; 
        const numLanes = config.numLanes;

        // ë²½ ë†’ì´ëŠ” í”Œë ˆì´ì–´ ì¶©ëŒ ë†’ì´ë³´ë‹¤ í›¨ì”¬ ë†’ê²Œ ì„¤ì • (í”¼í•  ìˆ˜ ì—†ê²Œ)
        const sizeX = 2; 
        const sizeY = config.trackHeight * 0.5; // í„°ë„ ë†’ì´ì˜ ì ˆë°˜
        const sizeZ = 0.5;

        // ì¥ì• ë¬¼ ì¤‘ì‹¬ Y ìœ„ì¹˜ (ë°”ë‹¥ ê¸°ì¤€: sizeY / 2)
        const wallCenterY = sizeY / 2; 

        // 1ê°œ ë˜ëŠ” 2ê°œì˜ ë ˆì¸ì„ ë§‰ìŒ
        const numBlocks = Math.random() < 0.6 ? 2 : 1; 
        
        let blockedLanes = new Set();
        // 1. ë§‰íˆì§€ ì•Šì„ ë ˆì¸(í†µë¡œ) ì„ íƒ
        let openLane = Math.floor(Math.random() * numLanes); 

        // 2. ë‚˜ë¨¸ì§€ ë ˆì¸ì„ ë§‰ìŒ
        for (let i = 0; i < numLanes; i++) {
            if (i !== openLane) {
                // ë‚¨ì€ ë ˆì¸ë“¤ ì¤‘ ëœë¤í•˜ê²Œ 1ê°œ(numBlocks=2ì¼ ê²½ìš°) ë˜ëŠ” 2ê°œ(numBlocks=1ì¼ ê²½ìš°)ë¥¼ ë§‰ìŒ
                if (numBlocks === 1 && Math.random() < 0.5 && blockedLanes.size === 1) {
                    continue; // 1ê°œë§Œ ë§‰ì•„ì•¼ í•  ê²½ìš° 50% í™•ë¥ ë¡œ ê±´ë„ˆëœ€
                }

                const geometry = new THREE.BoxGeometry(sizeX, sizeY, sizeZ);
                const material = new THREE.MeshBasicMaterial({
                    color: 0xff00ff, 
                    emissive: 0xff00ff,
                    emissiveIntensity: 1.5,
                    wireframe: false
                });
                const obstacle = new THREE.Mesh(geometry, material);

                obstacle.position.set(lanePositions[i], wallCenterY, spawnZ); 
                obstacle.userData.collisionBox = new THREE.Box3().setFromObject(obstacle);
                obstacle.userData.type = 'HAZARD';

                scene.add(obstacle);
                obstacles.push(obstacle);
                blockedLanes.add(i);

                if (blockedLanes.size >= numBlocks) break;
            }
        }
    }

    // 5. ì¶©ëŒ ê°ì§€ ë¡œì§ (Collision Detection Logic - Simplified)
    function checkCollision() {
        const playerBoundingBox = new THREE.Box3();
        
        // ê³ ì •ëœ í”Œë ˆì´ì–´ ì¶©ëŒ ë°•ìŠ¤
        playerBoundingBox.setFromCenterAndSize(
            new THREE.Vector3(player.position.x, player.position.y, player.position.z),
            new THREE.Vector3(0.5, COLLISION_HEIGHT, 0.5) // X, Z ë„ˆë¹„ëŠ” ê³ ì •, Y ë†’ì´ ê³ ì •
        );

        for (let i = 0; i < obstacles.length; i++) {
            const obstacle = obstacles[i];
            const obstacleBox = obstacle.userData.collisionBox.clone();
            
            if (playerBoundingBox.intersectsBox(obstacleBox)) {
                // ì¼ë°˜ ì¥ì• ë¬¼ì— ë‹¿ìœ¼ë©´ ê²Œì„ ì˜¤ë²„
                gameOver();
                return;
            }
        }
    }

    // 6. ê²Œì„ ì˜¤ë²„
    function gameOver() {
        gameState = 'gameover';
        console.log("Game Over! Score:", score.toFixed(0));

        if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = null;
        }

        // ìµœê³  ì ìˆ˜ ì—…ë°ì´íŠ¸ ë° ì €ì¥
        if (score > highscore) {
            highscore = score;
            highScoreDisplay.textContent = highscore.toFixed(0);
            if (Game.db && Game.userId) {
                Game.saveHighScore(Game.db, Game.appId, Game.userId, highscore);
            }
            messageBox.innerHTML = `
                <h1 class="text-3xl font-bold mb-4 neon-text text-yellow-300">ìµœê³  ì ìˆ˜ ê°±ì‹ !</h1>
                <p class="text-2xl mb-6">ìµœì¢… ì ìˆ˜: ${score.toFixed(0)}</p>
                <button id="restart-button" class="neon-button">ë‹¤ì‹œ ì‹œì‘</button>
            `;
        } else {
            messageBox.innerHTML = `
                <h1 class="text-3xl font-bold mb-4 neon-text text-red-500">ê²Œì„ ì˜¤ë²„</h1>
                <p class="text-2xl mb-6">ìµœì¢… ì ìˆ˜: ${score.toFixed(0)}</p>
                <p class="mb-4">ìµœê³  ì ìˆ˜: ${highscore.toFixed(0)}</p>
                <button id="restart-button" class="neon-button">ë‹¤ì‹œ ì‹œì‘</button>
            `;
        }

        document.getElementById('restart-button').addEventListener('click', startGame);
        messageBox.style.display = 'block';
    }

    // ì°½ í¬ê¸° ì¡°ì • í•¸ë“¤ëŸ¬ (Window Resize Handler)
    function onWindowResize() {
        // ì»¨í…Œì´ë„ˆ í¬ê¸° ê¸°ì¤€ìœ¼ë¡œ ìº”ë²„ìŠ¤ í¬ê¸° ê³„ì‚°
        const containerWidth = gameContainer.clientWidth;
        const containerHeight = gameContainer.clientHeight;
        
        // ìº”ë²„ìŠ¤ í¬ê¸°ë¥¼ ì»¨í…Œì´ë„ˆì˜ 95%(ë„ˆë¹„)ì™€ 75%(ë†’ì´)ë¡œ ì„¤ì •
        const width = containerWidth * 0.95; 
        const height = containerHeight * 0.75;

        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height);
    }


    // ì°½ ë¡œë“œ ì‹œ ì´ˆê¸°í™” ë° í¬ê¸° ì¡°ì •
    window.onload = function() {
        init();
        onWindowResize();

        if (Game.highScore !== undefined) {
            highScoreDisplay.textContent = Game.highScore.toFixed(0);
        }
    };
</script>

</body>
</html>